## Comunicación entre procesos


* Los procesos a menudo necesitan comunicarse entre sí para realizar tareas útiles. El sistema operativo proporciona varios mecanismos para permitir que los procesos se comuniquen entre sí.

* La memoria compartida es la forma más sencilla en que dos procesos pueden comunicarse entre sí. De manera predeterminada, dos procesos separados tienen dos imágenes de memoria separadas y no comparten ninguna memoria. (Nota: un proceso hijo bifurcado tiene la misma imagen de memoria que el proceso de padre en la creación, pero los cambios realizados en la memoria del proceso hijo no se reflejarán en el padre). Los procesos que deseen compartir memoria pueden solicitar al kernel un segmento de memoria compartida. Una vez que obtienen acceso al segmento de memoria compartida, se puede usar como memoria normal, con la propiedad de que los cambios realizados por un proceso serán visibles para el otro y viceversa.

* Un problema importante con el uso de la memoria compartida es el problema de la sincronización y las race conditions. Por ejemplo, si varios procesos comparten un segmento de memoria, es posible que dos procesos realicen una actualización concurrente, lo que da como resultado un valor incorrecto. Por lo tanto, se deben usar mecanismos de sincronización apropiados como el **locking** cuando se usa memoria compartida.

* Las señales (signals) son otra forma ligera de procesos y kernel para comunicarse entre sí y se utilizan principalmente para notificar procesos de eventos. Por ejemplo, cuando un usuario presiona Ctrl + C, el sistema operativo envía una señal llamada SIGINT al proceso en ejecución (como parte del manejo de la interrupción generada por el teclado). Cuando un proceso recibe una señal, la ejecución normal del proceso se detiene y el proceso ejecuta un fragmento de código separado llamado manejador de señal (handler signal). Una plantilla del proceso viene con manejadores de señal predeterminados para todas las señales, de modo que cada programa no necesitará tener código para manejar las señales. Por ejemplo, para la señal Ctrl + C, el proceso finalizará de manera predeterminada. Sin embargo, un programa puede tener su propia función de manejo de señal incorporada, que se puede pasar al kernel con la llamada al sistema **signal**. El sistema operativo invocará esta nueva función cuando el proceso reciba una señal. Las señales no son solo para la comunicación entre el sistema operativo y los procesos. Un proceso puede usar señales para comunicarse con otro proceso también. La llamada al sistema **kill** puede ser utilizada por un proceso para enviar una señal a otro proceso cuyo pid se especifica como un argumento para la llamada al sistema.

* Los sockets son un mecanismo para comunicarse entre dos procesos en la misma máquina, e incluso entre procesos en diferentes máquinas. Los sockets de red son una forma estándar para que dos procesos de la capa de aplicación que se ejecutan en diferentes máquinas (por ejemplo, un cliente web y un servidor web) intercambien datos entre sí. Del mismo modo, dos procesos en la misma máquina pueden usar sockets de dominio Unix para enviar y recibir mensajes entre sí. El uso de sockets de dominio Unix es muy similar al uso de sockets de red. Dicho esto, los sockets se usan más ampliamente para comunicarse entre hosts que entre procesos en el mismo host.

* Los sockets presentan un interesante caso de estudio sobre llamadas de sistema blocking (bloqueado) versus non blocking (no bloqueado). Algunas llamadas al sistema de socket (por ejemplo, aceptar, leer) están bloqueando. Por ejemplo, cuando un proceso lee desde un socket, la llamada del sistema se bloquea hasta que los datos aparecen en el socket. Como resultado, mientras el proceso está bloqueado, no puede manejar los datos que ingresan en ningún otro socket. Esto limita el número de comunicaciones concurrentes que un proceso puede mantener. Existen varias técnicas para solucionar este problema. Un proceso podría desequilibrar un nuevo proceso hijo para cada conexión que tenga, de modo que un proceso hijo pueda dedicarse a leer y escribir en una sola conexión. Alternativamente, se puede configurar un socket para que no se bloquee, y el proceso puede sondear periódicamente el socket para ver si han llegado datos. Finalmente, las llamadas al sistema como **select** se pueden usar para recibir notificaciones del kernel cuando un socket está listo para una lectura.
* Pipes: es una conexión semidúplex entre dos descriptores de archivo: los datos escritos en un descriptor de archivo se pueden leer a través del otro. Un par de descriptores de archivos se pueden enlazar de esta manera utilizando la llamada al sistema **pipe* ***. Los dos extremos del piele se denominan final de lectura y final de escritura. Leer y escribir en una pipe puede ser bloqueantes o no, dependiendo de cómo esté configurada el pipeline. El sistema operativo almacena los datos escritos en un pipe y los pone a disposición del proceso que los lee.

* Los pipe son anónimas, es decir, no hay forma de referirse a ellas fuera del proceso. El caso de uso típico de las pipes es que un proceso padre cree un pipe y entregue los puntos finales a uno o más hijos. Alternativamente, las  FIFO (Primero en entrar, primero en salir) permiten que un proceso cree un pipe con un nombre específico, de modo que también se pueda acceder a los puntos finales del pipe fuera del proceso.

* El paso de mensajes es otro mecanismo de comunicación entre procesos, proporcionado por muchos sistemas operativos. Un proceso puede crear una cola de mensajes (como un buzón), y otro proceso puede enviar un mensaje a esta cola a través del sistema operativo. Una cola de mensajes se mantiene como una lista vinculada dentro del kernel. Cada mensaje tiene un tipo, contenido y otras características opcionales como prioridad. Las llamadas al sistema están disponibles para crear una cola de mensajes, y publicar y recuperar mensajes de la cola. Como en los casos anteriores, están disponibles versiones bloqueantes y no bloqueantes de las llamadas al sistema. Por ejemplo, cuando la cola de mensajes está llena, el proceso de escritura puede elegir bloquear o regresar con un mensaje de error. Del mismo modo, cuando la cola de mensajes está vacía, la llamada del sistema para leer un mensaje puede bloquear o volver vacía.
