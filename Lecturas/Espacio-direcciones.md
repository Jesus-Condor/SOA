# El espacio de direcciones de un proceso

- El espacio de direcciones virtuales de un proceso tiene dos partes principales: la parte del usuario que contiene el código/datos del proceso en sí, y el código/datos del kernel. Por ejemplo, en un sistema x86 de 32 bits, las direcciones de 0 a 3 GB del espacio de direcciones virtuales de un proceso pueden contener datos del usuario, y las direcciones de 3 a 4 GB pueden apuntar al kernel. La tabla de páginas de cada proceso contiene asignaciones para las páginas del usuario y las páginas del kernel. Las entradas de la tabla de páginas del kernel son comunes para todos los procesos (ya que solo hay una copia física del kernel en la memoria), mientras que las entradas de la tabla de páginas del usuario son obviamente diferentes.

* Ten en cuenta que cada dirección de memoria física que esté en uso se "asignará" al espacio de direcciones virtuales de al menos un proceso. Es decir, la dirección de memoria física corresponderá a una dirección virtual en la tabla de páginas de algún proceso. La memoria física que no está asignada al espacio de direcciones de ningún proceso es, por definición, no accesible, ya que (casi) todos los accesos a la memoria se realizan a través de la MMU. Parte de la memoria física se puede asignar varias veces, por ejemplo, el código del kernel y los datos se asignan al espacio de direcciones virtuales de cada proceso.

*  ¿Por qué se asigna el kernel al espacio de direcciones de cada proceso? Tener el kernel en cada espacio de direcciones facilita la ejecución del código del kernel mientras está en modo kernel: no es necesario cambiar las tablas de páginas ni nada, y ejecutar el código del kernel es tan simple como saltar a una ubicación de memoria en la parte del kernel de la dirección espacio. Las tablas de páginas para las páginas del kernel tienen un conjunto de bits de protección especial, y la CPU debe estar en modo kernel para acceder a estas páginas y protegerse contra procesos no autorizados.

* La parte del usuario del espacio de direcciones contiene el código ejecutable del proceso y los datos asignados estáticamente. También contiene heap para la asignación dinámica de memoria y una pila, con el heap y la pila creciendo en direcciones opuestas entre sí. Las bibliotecas vinculadas dinámicamente, los archivos mapeados en memoria y otras cosas similares también forman parte del espacio de direcciones virtuales. Al asignar una parte del espacio de direcciones virtuales a los archivos mapeados en memoria, se puede acceder a los datos en estos archivos como cualquier otra variable en la memoria principal, y no a través de lecturas y escrituras en disco. El espacio de direcciones virtuales en Linux se divide en áreas de memoria o mapas para cada una de las entidades mencionadas anteriormente.


* La parte del kernel del espacio de direcciones contiene el código y los datos del kernel. Por ejemplo, tiene varias estructuras de datos del kernel, como la lista de procesos, páginas libres para asignar a nuevos procesos, etc. Las direcciones virtuales asignadas al código del kernel y los datos son las mismas en todos los procesos.

* Un concepto importante para entender aquí es que la mayoría de la memoria física se asignará (al menos) dos veces, una a la parte del kernel del espacio de direcciones de los procesos, y una vez a la parte del usuario de algún proceso. Para ver por qué, ten en cuenta que el kernel mantiene una lista de frames/páginas libres, que posteriormente se asignan para almacenar imágenes de proceso del usuario. Supongamos que el kernel asigna una dirección virtual, digamos V, a un frame libre de tamaño N bytes. Supongamos que el kernel mantiene un puntero de 4 bytes a esta página libre, cuyo valor es simplemente la dirección virtual inicial V de la página libre. Aunque el kernel solo necesita esta variable de puntero para rastrear la página, ten en cuenta que no puede asignar las direcciones virtuales [V, V + N) a ninguna otra variable, porque estas direcciones se refieren a la memoria en esa página y serán utilizadas por el kernel para leer/ escribir datos en esa página libre. Es decir, una página free bloquea una parte del tamaño de la página del espacio de direcciones del kernel. Ahora, cuando esta página se asigna a un nuevo proceso, el proceso le asignará un rango de direcciones virtuales diferente (por ejemplo, [U, U + N)), desde la parte del usuario de su espacio de direcciones virtuales, que será utilizado por el proceso para leer/escribir datos en modo de usuario. Entonces, el mismo frame físico también habrá bloqueado otra parte de las direcciones virtuales en el proceso, esta vez de la parte del usuario. Es decir, la misma memoria física se asigna dos veces, una en la parte del kernel del espacio de direcciones (para que el kernel pueda referirse a ella), y una vez en la parte del usuario del espacio de direcciones de un proceso (para que el proceso pueda consulte en modo de usuario).

* ¿Es este doble consumo de direcciones virtuales un problema? En arquitecturas donde los espacios de direcciones virtuales son mucho más grandes que la memoria física, esta duplicación no es un problema, y está bien que un byte de memoria física bloquee dos o más bytes de espacio de direcciones virtuales. Sin embargo, en sistemas con espacios de direcciones virtuales más pequeños (debido a la menor cantidad de bits disponibles para almacenar direcciones de memoria en los registros), sucederá uno de los siguientes casos: o no se utilizará toda la memoria física (como en el caso de xv6), o más comúnmente, alguna parte de la memoria del usuario no se asignará en el espacio de direcciones del kernel todo el tiempo (como en el caso de Linux). Es decir, una vez que el kernel asigna una página libre a un proceso, eliminará sus asignaciones de tablas de páginas que apuntan a esa memoria física y usará las direcciones virtuales liberadas para señalar algo más. Posteriormente, esta memoria física solo será accesible desde el modo de usuario de un proceso, porque solo las direcciones virtuales del usuario apuntan a ella en la tabla de páginas. Dicha memoria se denomina 'memoria alta -high memory' en Linux, y esta memoria se asigna al espacio de direcciones del kernel (es decir, las direcciones virtuales se asignan desde la parte del kernel de la memoria virtual) solo en función de las necesidades.